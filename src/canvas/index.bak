import {
  OptionsInterface,
  CanvaOptionsInterface,
  PointInterface,
  DrawInterface,
  KonvaInterface
} from '#/canvas'
import Konva from 'konva'

/***
 * 画布类
 * @param id 画布元素id
 * @param width 画布宽度
 * @param height 画布高度
 * @param stage 画布实例
 * @param layer 画布图层
 * @param point 画布上的点
 * @param groupPoint 画布组上的点
 * @param group 画布上的组
 * @param konvaList 画布上的图形列表
 */
export default class Draw implements DrawInterface {
  point: Array<PointInterface> = []
  groupPoint: Array<PointInterface> = []
  group: Konva.Group = new Konva.Group({ draggable: true })
  konvaList: Array<KonvaInterface> = []
  id: string
  height?: number
  width?: number
  stage: Konva.Stage
  layer: Konva.Layer = new Konva.Layer()

  constructor(options: CanvaOptionsInterface) {
    this.id = options.id as string
    if (!this.id) throw new Error('id 找不到')
    const el = document.getElementById(options.id)
    if (!el) throw new Error('找不到画布元素')
    this.width = options.width || el.offsetWidth || 300
    this.height = options.height || el.offsetHeight || 150
    this.stage = this.init()
    this.stage.add(this.layer)
  }

  init() {
    const stage = new Konva.Stage({
      container: this.id,
      width: this.width,
      height: this.height
    })
    return stage
  }

  drawCircle(x: number, y: number, radius: number, options?: OptionsInterface) {
    const circle = new Konva.Circle({
      x,
      y,
      radius,
      ...options
    })
    this.konvaList.push(circle)
    return circle
  }

  drawRect(x: number, y: number, width: number, height: number, options?: OptionsInterface) {
    const rect = new Konva.Rect({
      x,
      y,
      width,
      height,
      ...options
    })
    this.konvaList.push(rect)
    return rect
  }

  drawText(x: number, y: number, text: string, options?: OptionsInterface): Konva.Text {
    const textNode = new Konva.Text({
      x,
      y,
      text,
      ...options
    })
    this.konvaList.push(textNode)

    return textNode
  }

  drawLine(points: Array<number>, options?: OptionsInterface) {
    const line = new Konva.Line({
      points,
      ...options
    })
    this.konvaList.push(line)
    return line
  }

  addPoint(Point: PointInterface) {
    this.point.push(Point)
  }

  isPointInPath(x: number, y: number) {
    const point = this.point
    let isPointInPath = false
    for (let i = 0; i < point.length; i++) {
      const { minX, maxX, minY, maxY } = point[i]
      /**
       * 例子: { x:10,y: 20 } 是否在 arr =  [
       *     {  minX: 5, maxX:30, minY: 10, maxY:30  },
       *     ......
       * ] 中
       *
       * 大概图形如下:
       *    [5,10]             [30,10]
       *      ------------------
       *      |    (10,20)     |
       *      |                |
       *      ------------------
       *    [5,30]             [30,30]
       *
       *  x = 10, y = 20 得出判断条件: (5 <= 10 <= 30) && (10 <= 20 <= 30) 如果满足此条件就说明该坐标在图形内
       */
      if (minX <= x && x <= maxX && minY <= y && y <= maxY) {
        isPointInPath = true
        break
      }
      continue
    }

    return isPointInPath
  }

  centerPoint(width: number, height: number) {
    const { width: stageWidth, height: stageHeight } = this.stage.attrs

    const x = Math.ceil((stageWidth - width) / 2)
    const y = Math.ceil((stageHeight - height) / 2)

    return { x, y }
  }

  addLayer(layer: Konva.Layer) {
    this.stage.add(layer)
  }

  addGroup(group: Konva.Group) {
    this.layer.add(group)
  }

  addShape(shape: KonvaInterface) {
    this.layer.add(shape)
  }

  addShapeLayer(shape: KonvaInterface) {
    this.layer.add(shape)
  }

  addShapeLayerList(shapeList: Array<KonvaInterface>) {
    shapeList.forEach((shape) => {
      this.layer.add(shape)
    })
  }

  addShapeGroup(shape: KonvaInterface) {
    this.group.add(shape)
  }

  addShapeGroupList(shapeList: Array<KonvaInterface>) {
    shapeList.forEach((shape) => {
      this.group.add(shape)
    })
  }

  /**
   * 绘制所有有图形
   * @param shapes
   */
  run() {
    // this.layer.add(this.group)
    // this.stage.add(this.layer)
  }

  /**
   * 销毁
   * @returns void
   */
  destroy() {
    this.stage?.destroy()
  }
}
